// Generated by the protocol buffer compiler.  DO NOT EDIT!

#import "WorldClockProtocol.pb.h"
// @@protoc_insertion_point(imports)

@implementation WorldClockProtocolRoot
static PBExtensionRegistry* extensionRegistry = nil;
+ (PBExtensionRegistry*) extensionRegistry {
  return extensionRegistry;
}

+ (void) initialize {
  if (self == [WorldClockProtocolRoot class]) {
    PBMutableExtensionRegistry* registry = [PBMutableExtensionRegistry registry];
    [self registerAllExtensions:registry];
    extensionRegistry = registry;
  }
}
+ (void) registerAllExtensions:(PBMutableExtensionRegistry*) registry {
}
@end

BOOL ContinentIsValidValue(Continent value) {
  switch (value) {
    case ContinentAfrica:
    case ContinentAmerica:
    case ContinentAntarctica:
    case ContinentArctic:
    case ContinentAsia:
    case ContinentAtlantic:
    case ContinentAustralia:
    case ContinentEurope:
    case ContinentIndian:
    case ContinentMideast:
    case ContinentPacific:
      return YES;
    default:
      return NO;
  }
}
NSString *NSStringFromContinent(Continent value) {
  switch (value) {
    case ContinentAfrica:
      return @"ContinentAfrica";
    case ContinentAmerica:
      return @"ContinentAmerica";
    case ContinentAntarctica:
      return @"ContinentAntarctica";
    case ContinentArctic:
      return @"ContinentArctic";
    case ContinentAsia:
      return @"ContinentAsia";
    case ContinentAtlantic:
      return @"ContinentAtlantic";
    case ContinentAustralia:
      return @"ContinentAustralia";
    case ContinentEurope:
      return @"ContinentEurope";
    case ContinentIndian:
      return @"ContinentIndian";
    case ContinentMideast:
      return @"ContinentMideast";
    case ContinentPacific:
      return @"ContinentPacific";
    default:
      return nil;
  }
}

BOOL MCodeIsValidValue(MCode value) {
  switch (value) {
    case MCodePing:
    case MCodePong:
    case MCodeMsg:
      return YES;
    default:
      return NO;
  }
}
NSString *NSStringFromMCode(MCode value) {
  switch (value) {
    case MCodePing:
      return @"MCodePing";
    case MCodePong:
      return @"MCodePong";
    case MCodeMsg:
      return @"MCodeMsg";
    default:
      return nil;
  }
}

BOOL DayOfWeekIsValidValue(DayOfWeek value) {
  switch (value) {
    case DayOfWeekSunday:
    case DayOfWeekMonday:
    case DayOfWeekTuesday:
    case DayOfWeekWednesday:
    case DayOfWeekThursday:
    case DayOfWeekFriday:
    case DayOfWeekSaturday:
      return YES;
    default:
      return NO;
  }
}
NSString *NSStringFromDayOfWeek(DayOfWeek value) {
  switch (value) {
    case DayOfWeekSunday:
      return @"DayOfWeekSunday";
    case DayOfWeekMonday:
      return @"DayOfWeekMonday";
    case DayOfWeekTuesday:
      return @"DayOfWeekTuesday";
    case DayOfWeekWednesday:
      return @"DayOfWeekWednesday";
    case DayOfWeekThursday:
      return @"DayOfWeekThursday";
    case DayOfWeekFriday:
      return @"DayOfWeekFriday";
    case DayOfWeekSaturday:
      return @"DayOfWeekSaturday";
    default:
      return nil;
  }
}

@interface BaseMsg ()
@property MCode code;
@property (strong) NSString* msg;
@property (strong) NSString* from;
@property (strong) NSString* to;
@property (strong) NSMutableArray * locationArray;
@property (strong) NSMutableArray * localTimeArray;
@end

@implementation BaseMsg

- (BOOL) hasCode {
  return !!hasCode_;
}
- (void) setHasCode:(BOOL) _value_ {
  hasCode_ = !!_value_;
}
@synthesize code;
- (BOOL) hasMsg {
  return !!hasMsg_;
}
- (void) setHasMsg:(BOOL) _value_ {
  hasMsg_ = !!_value_;
}
@synthesize msg;
- (BOOL) hasFrom {
  return !!hasFrom_;
}
- (void) setHasFrom:(BOOL) _value_ {
  hasFrom_ = !!_value_;
}
@synthesize from;
- (BOOL) hasTo {
  return !!hasTo_;
}
- (void) setHasTo:(BOOL) _value_ {
  hasTo_ = !!_value_;
}
@synthesize to;
@synthesize locationArray;
@dynamic location;
@synthesize localTimeArray;
@dynamic localTime;
- (instancetype) init {
  if ((self = [super init])) {
    self.code = MCodePing;
    self.msg = @"";
    self.from = @"";
    self.to = @"";
  }
  return self;
}
static BaseMsg* defaultBaseMsgInstance = nil;
+ (void) initialize {
  if (self == [BaseMsg class]) {
    defaultBaseMsgInstance = [[BaseMsg alloc] init];
  }
}
+ (instancetype) defaultInstance {
  return defaultBaseMsgInstance;
}
- (instancetype) defaultInstance {
  return defaultBaseMsgInstance;
}
- (NSArray *)location {
  return locationArray;
}
- (Location*)locationAtIndex:(NSUInteger)index {
  return [locationArray objectAtIndex:index];
}
- (NSArray *)localTime {
  return localTimeArray;
}
- (LocalTime*)localTimeAtIndex:(NSUInteger)index {
  return [localTimeArray objectAtIndex:index];
}
- (BOOL) isInitialized {
  if (!self.hasCode) {
    return NO;
  }
  __block BOOL isInitlocation = YES;
   [self.location enumerateObjectsUsingBlock:^(Location *element, NSUInteger idx, BOOL *stop) {
    if (!element.isInitialized) {
      isInitlocation = NO;
      *stop = YES;
    }
  }];
  if (!isInitlocation) return isInitlocation;
  __block BOOL isInitlocalTime = YES;
   [self.localTime enumerateObjectsUsingBlock:^(LocalTime *element, NSUInteger idx, BOOL *stop) {
    if (!element.isInitialized) {
      isInitlocalTime = NO;
      *stop = YES;
    }
  }];
  if (!isInitlocalTime) return isInitlocalTime;
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasCode) {
    [output writeEnum:1 value:self.code];
  }
  if (self.hasFrom) {
    [output writeString:3 value:self.from];
  }
  if (self.hasTo) {
    [output writeString:4 value:self.to];
  }
  if (self.hasMsg) {
    [output writeString:5 value:self.msg];
  }
  [self.locationArray enumerateObjectsUsingBlock:^(Location *element, NSUInteger idx, BOOL *stop) {
    [output writeMessage:6 value:element];
  }];
  [self.localTimeArray enumerateObjectsUsingBlock:^(LocalTime *element, NSUInteger idx, BOOL *stop) {
    [output writeMessage:7 value:element];
  }];
  [self.unknownFields writeToCodedOutputStream:output];
}
- (SInt32) serializedSize {
  __block SInt32 size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasCode) {
    size_ += computeEnumSize(1, self.code);
  }
  if (self.hasFrom) {
    size_ += computeStringSize(3, self.from);
  }
  if (self.hasTo) {
    size_ += computeStringSize(4, self.to);
  }
  if (self.hasMsg) {
    size_ += computeStringSize(5, self.msg);
  }
  [self.locationArray enumerateObjectsUsingBlock:^(Location *element, NSUInteger idx, BOOL *stop) {
    size_ += computeMessageSize(6, element);
  }];
  [self.localTimeArray enumerateObjectsUsingBlock:^(LocalTime *element, NSUInteger idx, BOOL *stop) {
    size_ += computeMessageSize(7, element);
  }];
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (BaseMsg*) parseFromData:(NSData*) data {
  return (BaseMsg*)[[[BaseMsg builder] mergeFromData:data] build];
}
+ (BaseMsg*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (BaseMsg*)[[[BaseMsg builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (BaseMsg*) parseFromInputStream:(NSInputStream*) input {
  return (BaseMsg*)[[[BaseMsg builder] mergeFromInputStream:input] build];
}
+ (BaseMsg*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (BaseMsg*)[[[BaseMsg builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (BaseMsg*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (BaseMsg*)[[[BaseMsg builder] mergeFromCodedInputStream:input] build];
}
+ (BaseMsg*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (BaseMsg*)[[[BaseMsg builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (BaseMsgBuilder*) builder {
  return [[BaseMsgBuilder alloc] init];
}
+ (BaseMsgBuilder*) builderWithPrototype:(BaseMsg*) prototype {
  return [[BaseMsg builder] mergeFrom:prototype];
}
- (BaseMsgBuilder*) builder {
  return [BaseMsg builder];
}
- (BaseMsgBuilder*) toBuilder {
  return [BaseMsg builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasCode) {
    [output appendFormat:@"%@%@: %@\n", indent, @"code", NSStringFromMCode(self.code)];
  }
  if (self.hasFrom) {
    [output appendFormat:@"%@%@: %@\n", indent, @"from", self.from];
  }
  if (self.hasTo) {
    [output appendFormat:@"%@%@: %@\n", indent, @"to", self.to];
  }
  if (self.hasMsg) {
    [output appendFormat:@"%@%@: %@\n", indent, @"msg", self.msg];
  }
  [self.locationArray enumerateObjectsUsingBlock:^(Location *element, NSUInteger idx, BOOL *stop) {
    [output appendFormat:@"%@%@ {\n", indent, @"location"];
    [element writeDescriptionTo:output
                     withIndent:[NSString stringWithFormat:@"%@  ", indent]];
    [output appendFormat:@"%@}\n", indent];
  }];
  [self.localTimeArray enumerateObjectsUsingBlock:^(LocalTime *element, NSUInteger idx, BOOL *stop) {
    [output appendFormat:@"%@%@ {\n", indent, @"localTime"];
    [element writeDescriptionTo:output
                     withIndent:[NSString stringWithFormat:@"%@  ", indent]];
    [output appendFormat:@"%@}\n", indent];
  }];
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[BaseMsg class]]) {
    return NO;
  }
  BaseMsg *otherMessage = other;
  return
      self.hasCode == otherMessage.hasCode &&
      (!self.hasCode || self.code == otherMessage.code) &&
      self.hasFrom == otherMessage.hasFrom &&
      (!self.hasFrom || [self.from isEqual:otherMessage.from]) &&
      self.hasTo == otherMessage.hasTo &&
      (!self.hasTo || [self.to isEqual:otherMessage.to]) &&
      self.hasMsg == otherMessage.hasMsg &&
      (!self.hasMsg || [self.msg isEqual:otherMessage.msg]) &&
      [self.locationArray isEqualToArray:otherMessage.locationArray] &&
      [self.localTimeArray isEqualToArray:otherMessage.localTimeArray] &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  __block NSUInteger hashCode = 7;
  if (self.hasCode) {
    hashCode = hashCode * 31 + self.code;
  }
  if (self.hasFrom) {
    hashCode = hashCode * 31 + [self.from hash];
  }
  if (self.hasTo) {
    hashCode = hashCode * 31 + [self.to hash];
  }
  if (self.hasMsg) {
    hashCode = hashCode * 31 + [self.msg hash];
  }
  [self.locationArray enumerateObjectsUsingBlock:^(Location *element, NSUInteger idx, BOOL *stop) {
    hashCode = hashCode * 31 + [element hash];
  }];
  [self.localTimeArray enumerateObjectsUsingBlock:^(LocalTime *element, NSUInteger idx, BOOL *stop) {
    hashCode = hashCode * 31 + [element hash];
  }];
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

@interface BaseMsgBuilder()
@property (strong) BaseMsg* resultBaseMsg;
@end

@implementation BaseMsgBuilder
@synthesize resultBaseMsg;
- (instancetype) init {
  if ((self = [super init])) {
    self.resultBaseMsg = [[BaseMsg alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return resultBaseMsg;
}
- (BaseMsgBuilder*) clear {
  self.resultBaseMsg = [[BaseMsg alloc] init];
  return self;
}
- (BaseMsgBuilder*) clone {
  return [BaseMsg builderWithPrototype:resultBaseMsg];
}
- (BaseMsg*) defaultInstance {
  return [BaseMsg defaultInstance];
}
- (BaseMsg*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (BaseMsg*) buildPartial {
  BaseMsg* returnMe = resultBaseMsg;
  self.resultBaseMsg = nil;
  return returnMe;
}
- (BaseMsgBuilder*) mergeFrom:(BaseMsg*) other {
  if (other == [BaseMsg defaultInstance]) {
    return self;
  }
  if (other.hasCode) {
    [self setCode:other.code];
  }
  if (other.hasMsg) {
    [self setMsg:other.msg];
  }
  if (other.hasFrom) {
    [self setFrom:other.from];
  }
  if (other.hasTo) {
    [self setTo:other.to];
  }
  if (other.locationArray.count > 0) {
    if (resultBaseMsg.locationArray == nil) {
      resultBaseMsg.locationArray = [[NSMutableArray alloc] initWithArray:other.locationArray];
    } else {
      [resultBaseMsg.locationArray addObjectsFromArray:other.locationArray];
    }
  }
  if (other.localTimeArray.count > 0) {
    if (resultBaseMsg.localTimeArray == nil) {
      resultBaseMsg.localTimeArray = [[NSMutableArray alloc] initWithArray:other.localTimeArray];
    } else {
      [resultBaseMsg.localTimeArray addObjectsFromArray:other.localTimeArray];
    }
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (BaseMsgBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (BaseMsgBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSetBuilder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    SInt32 tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 8: {
        MCode value = (MCode)[input readEnum];
        if (MCodeIsValidValue(value)) {
          [self setCode:value];
        } else {
          [unknownFields mergeVarintField:1 value:value];
        }
        break;
      }
      case 26: {
        [self setFrom:[input readString]];
        break;
      }
      case 34: {
        [self setTo:[input readString]];
        break;
      }
      case 42: {
        [self setMsg:[input readString]];
        break;
      }
      case 50: {
        LocationBuilder* subBuilder = [Location builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addLocation:[subBuilder buildPartial]];
        break;
      }
      case 58: {
        LocalTimeBuilder* subBuilder = [LocalTime builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addLocalTime:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (BOOL) hasCode {
  return resultBaseMsg.hasCode;
}
- (MCode) code {
  return resultBaseMsg.code;
}
- (BaseMsgBuilder*) setCode:(MCode) value {
  resultBaseMsg.hasCode = YES;
  resultBaseMsg.code = value;
  return self;
}
- (BaseMsgBuilder*) clearCode {
  resultBaseMsg.hasCode = NO;
  resultBaseMsg.code = MCodePing;
  return self;
}
- (BOOL) hasMsg {
  return resultBaseMsg.hasMsg;
}
- (NSString*) msg {
  return resultBaseMsg.msg;
}
- (BaseMsgBuilder*) setMsg:(NSString*) value {
  resultBaseMsg.hasMsg = YES;
  resultBaseMsg.msg = value;
  return self;
}
- (BaseMsgBuilder*) clearMsg {
  resultBaseMsg.hasMsg = NO;
  resultBaseMsg.msg = @"";
  return self;
}
- (BOOL) hasFrom {
  return resultBaseMsg.hasFrom;
}
- (NSString*) from {
  return resultBaseMsg.from;
}
- (BaseMsgBuilder*) setFrom:(NSString*) value {
  resultBaseMsg.hasFrom = YES;
  resultBaseMsg.from = value;
  return self;
}
- (BaseMsgBuilder*) clearFrom {
  resultBaseMsg.hasFrom = NO;
  resultBaseMsg.from = @"";
  return self;
}
- (BOOL) hasTo {
  return resultBaseMsg.hasTo;
}
- (NSString*) to {
  return resultBaseMsg.to;
}
- (BaseMsgBuilder*) setTo:(NSString*) value {
  resultBaseMsg.hasTo = YES;
  resultBaseMsg.to = value;
  return self;
}
- (BaseMsgBuilder*) clearTo {
  resultBaseMsg.hasTo = NO;
  resultBaseMsg.to = @"";
  return self;
}
- (NSMutableArray *)location {
  return resultBaseMsg.locationArray;
}
- (Location*)locationAtIndex:(NSUInteger)index {
  return [resultBaseMsg locationAtIndex:index];
}
- (BaseMsgBuilder *)addLocation:(Location*)value {
  if (resultBaseMsg.locationArray == nil) {
    resultBaseMsg.locationArray = [[NSMutableArray alloc]init];
  }
  [resultBaseMsg.locationArray addObject:value];
  return self;
}
- (BaseMsgBuilder *)setLocationArray:(NSArray *)array {
  resultBaseMsg.locationArray = [[NSMutableArray alloc]initWithArray:array];
  return self;
}
- (BaseMsgBuilder *)clearLocation {
  resultBaseMsg.locationArray = nil;
  return self;
}
- (NSMutableArray *)localTime {
  return resultBaseMsg.localTimeArray;
}
- (LocalTime*)localTimeAtIndex:(NSUInteger)index {
  return [resultBaseMsg localTimeAtIndex:index];
}
- (BaseMsgBuilder *)addLocalTime:(LocalTime*)value {
  if (resultBaseMsg.localTimeArray == nil) {
    resultBaseMsg.localTimeArray = [[NSMutableArray alloc]init];
  }
  [resultBaseMsg.localTimeArray addObject:value];
  return self;
}
- (BaseMsgBuilder *)setLocalTimeArray:(NSArray *)array {
  resultBaseMsg.localTimeArray = [[NSMutableArray alloc]initWithArray:array];
  return self;
}
- (BaseMsgBuilder *)clearLocalTime {
  resultBaseMsg.localTimeArray = nil;
  return self;
}
@end

@interface Location ()
@property Continent continent;
@property (strong) NSString* city;
@end

@implementation Location

- (BOOL) hasContinent {
  return !!hasContinent_;
}
- (void) setHasContinent:(BOOL) _value_ {
  hasContinent_ = !!_value_;
}
@synthesize continent;
- (BOOL) hasCity {
  return !!hasCity_;
}
- (void) setHasCity:(BOOL) _value_ {
  hasCity_ = !!_value_;
}
@synthesize city;
- (instancetype) init {
  if ((self = [super init])) {
    self.continent = ContinentAfrica;
    self.city = @"";
  }
  return self;
}
static Location* defaultLocationInstance = nil;
+ (void) initialize {
  if (self == [Location class]) {
    defaultLocationInstance = [[Location alloc] init];
  }
}
+ (instancetype) defaultInstance {
  return defaultLocationInstance;
}
- (instancetype) defaultInstance {
  return defaultLocationInstance;
}
- (BOOL) isInitialized {
  if (!self.hasContinent) {
    return NO;
  }
  if (!self.hasCity) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasContinent) {
    [output writeEnum:1 value:self.continent];
  }
  if (self.hasCity) {
    [output writeString:2 value:self.city];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (SInt32) serializedSize {
  __block SInt32 size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasContinent) {
    size_ += computeEnumSize(1, self.continent);
  }
  if (self.hasCity) {
    size_ += computeStringSize(2, self.city);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (Location*) parseFromData:(NSData*) data {
  return (Location*)[[[Location builder] mergeFromData:data] build];
}
+ (Location*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (Location*)[[[Location builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (Location*) parseFromInputStream:(NSInputStream*) input {
  return (Location*)[[[Location builder] mergeFromInputStream:input] build];
}
+ (Location*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (Location*)[[[Location builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (Location*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (Location*)[[[Location builder] mergeFromCodedInputStream:input] build];
}
+ (Location*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (Location*)[[[Location builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (LocationBuilder*) builder {
  return [[LocationBuilder alloc] init];
}
+ (LocationBuilder*) builderWithPrototype:(Location*) prototype {
  return [[Location builder] mergeFrom:prototype];
}
- (LocationBuilder*) builder {
  return [Location builder];
}
- (LocationBuilder*) toBuilder {
  return [Location builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasContinent) {
    [output appendFormat:@"%@%@: %@\n", indent, @"continent", NSStringFromContinent(self.continent)];
  }
  if (self.hasCity) {
    [output appendFormat:@"%@%@: %@\n", indent, @"city", self.city];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[Location class]]) {
    return NO;
  }
  Location *otherMessage = other;
  return
      self.hasContinent == otherMessage.hasContinent &&
      (!self.hasContinent || self.continent == otherMessage.continent) &&
      self.hasCity == otherMessage.hasCity &&
      (!self.hasCity || [self.city isEqual:otherMessage.city]) &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  __block NSUInteger hashCode = 7;
  if (self.hasContinent) {
    hashCode = hashCode * 31 + self.continent;
  }
  if (self.hasCity) {
    hashCode = hashCode * 31 + [self.city hash];
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

@interface LocationBuilder()
@property (strong) Location* resultLocation;
@end

@implementation LocationBuilder
@synthesize resultLocation;
- (instancetype) init {
  if ((self = [super init])) {
    self.resultLocation = [[Location alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return resultLocation;
}
- (LocationBuilder*) clear {
  self.resultLocation = [[Location alloc] init];
  return self;
}
- (LocationBuilder*) clone {
  return [Location builderWithPrototype:resultLocation];
}
- (Location*) defaultInstance {
  return [Location defaultInstance];
}
- (Location*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (Location*) buildPartial {
  Location* returnMe = resultLocation;
  self.resultLocation = nil;
  return returnMe;
}
- (LocationBuilder*) mergeFrom:(Location*) other {
  if (other == [Location defaultInstance]) {
    return self;
  }
  if (other.hasContinent) {
    [self setContinent:other.continent];
  }
  if (other.hasCity) {
    [self setCity:other.city];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (LocationBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (LocationBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSetBuilder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    SInt32 tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 8: {
        Continent value = (Continent)[input readEnum];
        if (ContinentIsValidValue(value)) {
          [self setContinent:value];
        } else {
          [unknownFields mergeVarintField:1 value:value];
        }
        break;
      }
      case 18: {
        [self setCity:[input readString]];
        break;
      }
    }
  }
}
- (BOOL) hasContinent {
  return resultLocation.hasContinent;
}
- (Continent) continent {
  return resultLocation.continent;
}
- (LocationBuilder*) setContinent:(Continent) value {
  resultLocation.hasContinent = YES;
  resultLocation.continent = value;
  return self;
}
- (LocationBuilder*) clearContinent {
  resultLocation.hasContinent = NO;
  resultLocation.continent = ContinentAfrica;
  return self;
}
- (BOOL) hasCity {
  return resultLocation.hasCity;
}
- (NSString*) city {
  return resultLocation.city;
}
- (LocationBuilder*) setCity:(NSString*) value {
  resultLocation.hasCity = YES;
  resultLocation.city = value;
  return self;
}
- (LocationBuilder*) clearCity {
  resultLocation.hasCity = NO;
  resultLocation.city = @"";
  return self;
}
@end

@interface Locations ()
@property (strong) NSMutableArray * locationArray;
@end

@implementation Locations

@synthesize locationArray;
@dynamic location;
- (instancetype) init {
  if ((self = [super init])) {
  }
  return self;
}
static Locations* defaultLocationsInstance = nil;
+ (void) initialize {
  if (self == [Locations class]) {
    defaultLocationsInstance = [[Locations alloc] init];
  }
}
+ (instancetype) defaultInstance {
  return defaultLocationsInstance;
}
- (instancetype) defaultInstance {
  return defaultLocationsInstance;
}
- (NSArray *)location {
  return locationArray;
}
- (Location*)locationAtIndex:(NSUInteger)index {
  return [locationArray objectAtIndex:index];
}
- (BOOL) isInitialized {
  __block BOOL isInitlocation = YES;
   [self.location enumerateObjectsUsingBlock:^(Location *element, NSUInteger idx, BOOL *stop) {
    if (!element.isInitialized) {
      isInitlocation = NO;
      *stop = YES;
    }
  }];
  if (!isInitlocation) return isInitlocation;
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  [self.locationArray enumerateObjectsUsingBlock:^(Location *element, NSUInteger idx, BOOL *stop) {
    [output writeMessage:1 value:element];
  }];
  [self.unknownFields writeToCodedOutputStream:output];
}
- (SInt32) serializedSize {
  __block SInt32 size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  [self.locationArray enumerateObjectsUsingBlock:^(Location *element, NSUInteger idx, BOOL *stop) {
    size_ += computeMessageSize(1, element);
  }];
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (Locations*) parseFromData:(NSData*) data {
  return (Locations*)[[[Locations builder] mergeFromData:data] build];
}
+ (Locations*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (Locations*)[[[Locations builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (Locations*) parseFromInputStream:(NSInputStream*) input {
  return (Locations*)[[[Locations builder] mergeFromInputStream:input] build];
}
+ (Locations*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (Locations*)[[[Locations builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (Locations*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (Locations*)[[[Locations builder] mergeFromCodedInputStream:input] build];
}
+ (Locations*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (Locations*)[[[Locations builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (LocationsBuilder*) builder {
  return [[LocationsBuilder alloc] init];
}
+ (LocationsBuilder*) builderWithPrototype:(Locations*) prototype {
  return [[Locations builder] mergeFrom:prototype];
}
- (LocationsBuilder*) builder {
  return [Locations builder];
}
- (LocationsBuilder*) toBuilder {
  return [Locations builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  [self.locationArray enumerateObjectsUsingBlock:^(Location *element, NSUInteger idx, BOOL *stop) {
    [output appendFormat:@"%@%@ {\n", indent, @"location"];
    [element writeDescriptionTo:output
                     withIndent:[NSString stringWithFormat:@"%@  ", indent]];
    [output appendFormat:@"%@}\n", indent];
  }];
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[Locations class]]) {
    return NO;
  }
  Locations *otherMessage = other;
  return
      [self.locationArray isEqualToArray:otherMessage.locationArray] &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  __block NSUInteger hashCode = 7;
  [self.locationArray enumerateObjectsUsingBlock:^(Location *element, NSUInteger idx, BOOL *stop) {
    hashCode = hashCode * 31 + [element hash];
  }];
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

@interface LocationsBuilder()
@property (strong) Locations* resultLocations;
@end

@implementation LocationsBuilder
@synthesize resultLocations;
- (instancetype) init {
  if ((self = [super init])) {
    self.resultLocations = [[Locations alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return resultLocations;
}
- (LocationsBuilder*) clear {
  self.resultLocations = [[Locations alloc] init];
  return self;
}
- (LocationsBuilder*) clone {
  return [Locations builderWithPrototype:resultLocations];
}
- (Locations*) defaultInstance {
  return [Locations defaultInstance];
}
- (Locations*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (Locations*) buildPartial {
  Locations* returnMe = resultLocations;
  self.resultLocations = nil;
  return returnMe;
}
- (LocationsBuilder*) mergeFrom:(Locations*) other {
  if (other == [Locations defaultInstance]) {
    return self;
  }
  if (other.locationArray.count > 0) {
    if (resultLocations.locationArray == nil) {
      resultLocations.locationArray = [[NSMutableArray alloc] initWithArray:other.locationArray];
    } else {
      [resultLocations.locationArray addObjectsFromArray:other.locationArray];
    }
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (LocationsBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (LocationsBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSetBuilder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    SInt32 tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        LocationBuilder* subBuilder = [Location builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addLocation:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (NSMutableArray *)location {
  return resultLocations.locationArray;
}
- (Location*)locationAtIndex:(NSUInteger)index {
  return [resultLocations locationAtIndex:index];
}
- (LocationsBuilder *)addLocation:(Location*)value {
  if (resultLocations.locationArray == nil) {
    resultLocations.locationArray = [[NSMutableArray alloc]init];
  }
  [resultLocations.locationArray addObject:value];
  return self;
}
- (LocationsBuilder *)setLocationArray:(NSArray *)array {
  resultLocations.locationArray = [[NSMutableArray alloc]initWithArray:array];
  return self;
}
- (LocationsBuilder *)clearLocation {
  resultLocations.locationArray = nil;
  return self;
}
@end

@interface LocalTime ()
@property UInt32 year;
@property UInt32 month;
@property UInt32 dayOfMonth;
@property DayOfWeek dayOfWeek;
@property UInt32 hour;
@property UInt32 minute;
@property UInt32 second;
@end

@implementation LocalTime

- (BOOL) hasYear {
  return !!hasYear_;
}
- (void) setHasYear:(BOOL) _value_ {
  hasYear_ = !!_value_;
}
@synthesize year;
- (BOOL) hasMonth {
  return !!hasMonth_;
}
- (void) setHasMonth:(BOOL) _value_ {
  hasMonth_ = !!_value_;
}
@synthesize month;
- (BOOL) hasDayOfMonth {
  return !!hasDayOfMonth_;
}
- (void) setHasDayOfMonth:(BOOL) _value_ {
  hasDayOfMonth_ = !!_value_;
}
@synthesize dayOfMonth;
- (BOOL) hasDayOfWeek {
  return !!hasDayOfWeek_;
}
- (void) setHasDayOfWeek:(BOOL) _value_ {
  hasDayOfWeek_ = !!_value_;
}
@synthesize dayOfWeek;
- (BOOL) hasHour {
  return !!hasHour_;
}
- (void) setHasHour:(BOOL) _value_ {
  hasHour_ = !!_value_;
}
@synthesize hour;
- (BOOL) hasMinute {
  return !!hasMinute_;
}
- (void) setHasMinute:(BOOL) _value_ {
  hasMinute_ = !!_value_;
}
@synthesize minute;
- (BOOL) hasSecond {
  return !!hasSecond_;
}
- (void) setHasSecond:(BOOL) _value_ {
  hasSecond_ = !!_value_;
}
@synthesize second;
- (instancetype) init {
  if ((self = [super init])) {
    self.year = 0;
    self.month = 0;
    self.dayOfMonth = 0;
    self.dayOfWeek = DayOfWeekSunday;
    self.hour = 0;
    self.minute = 0;
    self.second = 0;
  }
  return self;
}
static LocalTime* defaultLocalTimeInstance = nil;
+ (void) initialize {
  if (self == [LocalTime class]) {
    defaultLocalTimeInstance = [[LocalTime alloc] init];
  }
}
+ (instancetype) defaultInstance {
  return defaultLocalTimeInstance;
}
- (instancetype) defaultInstance {
  return defaultLocalTimeInstance;
}
- (BOOL) isInitialized {
  if (!self.hasYear) {
    return NO;
  }
  if (!self.hasMonth) {
    return NO;
  }
  if (!self.hasDayOfMonth) {
    return NO;
  }
  if (!self.hasDayOfWeek) {
    return NO;
  }
  if (!self.hasHour) {
    return NO;
  }
  if (!self.hasMinute) {
    return NO;
  }
  if (!self.hasSecond) {
    return NO;
  }
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasYear) {
    [output writeUInt32:1 value:self.year];
  }
  if (self.hasMonth) {
    [output writeUInt32:2 value:self.month];
  }
  if (self.hasDayOfMonth) {
    [output writeUInt32:4 value:self.dayOfMonth];
  }
  if (self.hasDayOfWeek) {
    [output writeEnum:5 value:self.dayOfWeek];
  }
  if (self.hasHour) {
    [output writeUInt32:6 value:self.hour];
  }
  if (self.hasMinute) {
    [output writeUInt32:7 value:self.minute];
  }
  if (self.hasSecond) {
    [output writeUInt32:8 value:self.second];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (SInt32) serializedSize {
  __block SInt32 size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasYear) {
    size_ += computeUInt32Size(1, self.year);
  }
  if (self.hasMonth) {
    size_ += computeUInt32Size(2, self.month);
  }
  if (self.hasDayOfMonth) {
    size_ += computeUInt32Size(4, self.dayOfMonth);
  }
  if (self.hasDayOfWeek) {
    size_ += computeEnumSize(5, self.dayOfWeek);
  }
  if (self.hasHour) {
    size_ += computeUInt32Size(6, self.hour);
  }
  if (self.hasMinute) {
    size_ += computeUInt32Size(7, self.minute);
  }
  if (self.hasSecond) {
    size_ += computeUInt32Size(8, self.second);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (LocalTime*) parseFromData:(NSData*) data {
  return (LocalTime*)[[[LocalTime builder] mergeFromData:data] build];
}
+ (LocalTime*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (LocalTime*)[[[LocalTime builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (LocalTime*) parseFromInputStream:(NSInputStream*) input {
  return (LocalTime*)[[[LocalTime builder] mergeFromInputStream:input] build];
}
+ (LocalTime*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (LocalTime*)[[[LocalTime builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (LocalTime*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (LocalTime*)[[[LocalTime builder] mergeFromCodedInputStream:input] build];
}
+ (LocalTime*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (LocalTime*)[[[LocalTime builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (LocalTimeBuilder*) builder {
  return [[LocalTimeBuilder alloc] init];
}
+ (LocalTimeBuilder*) builderWithPrototype:(LocalTime*) prototype {
  return [[LocalTime builder] mergeFrom:prototype];
}
- (LocalTimeBuilder*) builder {
  return [LocalTime builder];
}
- (LocalTimeBuilder*) toBuilder {
  return [LocalTime builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasYear) {
    [output appendFormat:@"%@%@: %@\n", indent, @"year", [NSNumber numberWithInteger:self.year]];
  }
  if (self.hasMonth) {
    [output appendFormat:@"%@%@: %@\n", indent, @"month", [NSNumber numberWithInteger:self.month]];
  }
  if (self.hasDayOfMonth) {
    [output appendFormat:@"%@%@: %@\n", indent, @"dayOfMonth", [NSNumber numberWithInteger:self.dayOfMonth]];
  }
  if (self.hasDayOfWeek) {
    [output appendFormat:@"%@%@: %@\n", indent, @"dayOfWeek", NSStringFromDayOfWeek(self.dayOfWeek)];
  }
  if (self.hasHour) {
    [output appendFormat:@"%@%@: %@\n", indent, @"hour", [NSNumber numberWithInteger:self.hour]];
  }
  if (self.hasMinute) {
    [output appendFormat:@"%@%@: %@\n", indent, @"minute", [NSNumber numberWithInteger:self.minute]];
  }
  if (self.hasSecond) {
    [output appendFormat:@"%@%@: %@\n", indent, @"second", [NSNumber numberWithInteger:self.second]];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[LocalTime class]]) {
    return NO;
  }
  LocalTime *otherMessage = other;
  return
      self.hasYear == otherMessage.hasYear &&
      (!self.hasYear || self.year == otherMessage.year) &&
      self.hasMonth == otherMessage.hasMonth &&
      (!self.hasMonth || self.month == otherMessage.month) &&
      self.hasDayOfMonth == otherMessage.hasDayOfMonth &&
      (!self.hasDayOfMonth || self.dayOfMonth == otherMessage.dayOfMonth) &&
      self.hasDayOfWeek == otherMessage.hasDayOfWeek &&
      (!self.hasDayOfWeek || self.dayOfWeek == otherMessage.dayOfWeek) &&
      self.hasHour == otherMessage.hasHour &&
      (!self.hasHour || self.hour == otherMessage.hour) &&
      self.hasMinute == otherMessage.hasMinute &&
      (!self.hasMinute || self.minute == otherMessage.minute) &&
      self.hasSecond == otherMessage.hasSecond &&
      (!self.hasSecond || self.second == otherMessage.second) &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  __block NSUInteger hashCode = 7;
  if (self.hasYear) {
    hashCode = hashCode * 31 + [[NSNumber numberWithInteger:self.year] hash];
  }
  if (self.hasMonth) {
    hashCode = hashCode * 31 + [[NSNumber numberWithInteger:self.month] hash];
  }
  if (self.hasDayOfMonth) {
    hashCode = hashCode * 31 + [[NSNumber numberWithInteger:self.dayOfMonth] hash];
  }
  if (self.hasDayOfWeek) {
    hashCode = hashCode * 31 + self.dayOfWeek;
  }
  if (self.hasHour) {
    hashCode = hashCode * 31 + [[NSNumber numberWithInteger:self.hour] hash];
  }
  if (self.hasMinute) {
    hashCode = hashCode * 31 + [[NSNumber numberWithInteger:self.minute] hash];
  }
  if (self.hasSecond) {
    hashCode = hashCode * 31 + [[NSNumber numberWithInteger:self.second] hash];
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

@interface LocalTimeBuilder()
@property (strong) LocalTime* resultLocalTime;
@end

@implementation LocalTimeBuilder
@synthesize resultLocalTime;
- (instancetype) init {
  if ((self = [super init])) {
    self.resultLocalTime = [[LocalTime alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return resultLocalTime;
}
- (LocalTimeBuilder*) clear {
  self.resultLocalTime = [[LocalTime alloc] init];
  return self;
}
- (LocalTimeBuilder*) clone {
  return [LocalTime builderWithPrototype:resultLocalTime];
}
- (LocalTime*) defaultInstance {
  return [LocalTime defaultInstance];
}
- (LocalTime*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (LocalTime*) buildPartial {
  LocalTime* returnMe = resultLocalTime;
  self.resultLocalTime = nil;
  return returnMe;
}
- (LocalTimeBuilder*) mergeFrom:(LocalTime*) other {
  if (other == [LocalTime defaultInstance]) {
    return self;
  }
  if (other.hasYear) {
    [self setYear:other.year];
  }
  if (other.hasMonth) {
    [self setMonth:other.month];
  }
  if (other.hasDayOfMonth) {
    [self setDayOfMonth:other.dayOfMonth];
  }
  if (other.hasDayOfWeek) {
    [self setDayOfWeek:other.dayOfWeek];
  }
  if (other.hasHour) {
    [self setHour:other.hour];
  }
  if (other.hasMinute) {
    [self setMinute:other.minute];
  }
  if (other.hasSecond) {
    [self setSecond:other.second];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (LocalTimeBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (LocalTimeBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSetBuilder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    SInt32 tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 8: {
        [self setYear:[input readUInt32]];
        break;
      }
      case 16: {
        [self setMonth:[input readUInt32]];
        break;
      }
      case 32: {
        [self setDayOfMonth:[input readUInt32]];
        break;
      }
      case 40: {
        DayOfWeek value = (DayOfWeek)[input readEnum];
        if (DayOfWeekIsValidValue(value)) {
          [self setDayOfWeek:value];
        } else {
          [unknownFields mergeVarintField:5 value:value];
        }
        break;
      }
      case 48: {
        [self setHour:[input readUInt32]];
        break;
      }
      case 56: {
        [self setMinute:[input readUInt32]];
        break;
      }
      case 64: {
        [self setSecond:[input readUInt32]];
        break;
      }
    }
  }
}
- (BOOL) hasYear {
  return resultLocalTime.hasYear;
}
- (UInt32) year {
  return resultLocalTime.year;
}
- (LocalTimeBuilder*) setYear:(UInt32) value {
  resultLocalTime.hasYear = YES;
  resultLocalTime.year = value;
  return self;
}
- (LocalTimeBuilder*) clearYear {
  resultLocalTime.hasYear = NO;
  resultLocalTime.year = 0;
  return self;
}
- (BOOL) hasMonth {
  return resultLocalTime.hasMonth;
}
- (UInt32) month {
  return resultLocalTime.month;
}
- (LocalTimeBuilder*) setMonth:(UInt32) value {
  resultLocalTime.hasMonth = YES;
  resultLocalTime.month = value;
  return self;
}
- (LocalTimeBuilder*) clearMonth {
  resultLocalTime.hasMonth = NO;
  resultLocalTime.month = 0;
  return self;
}
- (BOOL) hasDayOfMonth {
  return resultLocalTime.hasDayOfMonth;
}
- (UInt32) dayOfMonth {
  return resultLocalTime.dayOfMonth;
}
- (LocalTimeBuilder*) setDayOfMonth:(UInt32) value {
  resultLocalTime.hasDayOfMonth = YES;
  resultLocalTime.dayOfMonth = value;
  return self;
}
- (LocalTimeBuilder*) clearDayOfMonth {
  resultLocalTime.hasDayOfMonth = NO;
  resultLocalTime.dayOfMonth = 0;
  return self;
}
- (BOOL) hasDayOfWeek {
  return resultLocalTime.hasDayOfWeek;
}
- (DayOfWeek) dayOfWeek {
  return resultLocalTime.dayOfWeek;
}
- (LocalTimeBuilder*) setDayOfWeek:(DayOfWeek) value {
  resultLocalTime.hasDayOfWeek = YES;
  resultLocalTime.dayOfWeek = value;
  return self;
}
- (LocalTimeBuilder*) clearDayOfWeek {
  resultLocalTime.hasDayOfWeek = NO;
  resultLocalTime.dayOfWeek = DayOfWeekSunday;
  return self;
}
- (BOOL) hasHour {
  return resultLocalTime.hasHour;
}
- (UInt32) hour {
  return resultLocalTime.hour;
}
- (LocalTimeBuilder*) setHour:(UInt32) value {
  resultLocalTime.hasHour = YES;
  resultLocalTime.hour = value;
  return self;
}
- (LocalTimeBuilder*) clearHour {
  resultLocalTime.hasHour = NO;
  resultLocalTime.hour = 0;
  return self;
}
- (BOOL) hasMinute {
  return resultLocalTime.hasMinute;
}
- (UInt32) minute {
  return resultLocalTime.minute;
}
- (LocalTimeBuilder*) setMinute:(UInt32) value {
  resultLocalTime.hasMinute = YES;
  resultLocalTime.minute = value;
  return self;
}
- (LocalTimeBuilder*) clearMinute {
  resultLocalTime.hasMinute = NO;
  resultLocalTime.minute = 0;
  return self;
}
- (BOOL) hasSecond {
  return resultLocalTime.hasSecond;
}
- (UInt32) second {
  return resultLocalTime.second;
}
- (LocalTimeBuilder*) setSecond:(UInt32) value {
  resultLocalTime.hasSecond = YES;
  resultLocalTime.second = value;
  return self;
}
- (LocalTimeBuilder*) clearSecond {
  resultLocalTime.hasSecond = NO;
  resultLocalTime.second = 0;
  return self;
}
@end

@interface LocalTimes ()
@property (strong) NSMutableArray * localTimeArray;
@end

@implementation LocalTimes

@synthesize localTimeArray;
@dynamic localTime;
- (instancetype) init {
  if ((self = [super init])) {
  }
  return self;
}
static LocalTimes* defaultLocalTimesInstance = nil;
+ (void) initialize {
  if (self == [LocalTimes class]) {
    defaultLocalTimesInstance = [[LocalTimes alloc] init];
  }
}
+ (instancetype) defaultInstance {
  return defaultLocalTimesInstance;
}
- (instancetype) defaultInstance {
  return defaultLocalTimesInstance;
}
- (NSArray *)localTime {
  return localTimeArray;
}
- (LocalTime*)localTimeAtIndex:(NSUInteger)index {
  return [localTimeArray objectAtIndex:index];
}
- (BOOL) isInitialized {
  __block BOOL isInitlocalTime = YES;
   [self.localTime enumerateObjectsUsingBlock:^(LocalTime *element, NSUInteger idx, BOOL *stop) {
    if (!element.isInitialized) {
      isInitlocalTime = NO;
      *stop = YES;
    }
  }];
  if (!isInitlocalTime) return isInitlocalTime;
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  [self.localTimeArray enumerateObjectsUsingBlock:^(LocalTime *element, NSUInteger idx, BOOL *stop) {
    [output writeMessage:1 value:element];
  }];
  [self.unknownFields writeToCodedOutputStream:output];
}
- (SInt32) serializedSize {
  __block SInt32 size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  [self.localTimeArray enumerateObjectsUsingBlock:^(LocalTime *element, NSUInteger idx, BOOL *stop) {
    size_ += computeMessageSize(1, element);
  }];
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (LocalTimes*) parseFromData:(NSData*) data {
  return (LocalTimes*)[[[LocalTimes builder] mergeFromData:data] build];
}
+ (LocalTimes*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (LocalTimes*)[[[LocalTimes builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (LocalTimes*) parseFromInputStream:(NSInputStream*) input {
  return (LocalTimes*)[[[LocalTimes builder] mergeFromInputStream:input] build];
}
+ (LocalTimes*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (LocalTimes*)[[[LocalTimes builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (LocalTimes*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (LocalTimes*)[[[LocalTimes builder] mergeFromCodedInputStream:input] build];
}
+ (LocalTimes*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (LocalTimes*)[[[LocalTimes builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (LocalTimesBuilder*) builder {
  return [[LocalTimesBuilder alloc] init];
}
+ (LocalTimesBuilder*) builderWithPrototype:(LocalTimes*) prototype {
  return [[LocalTimes builder] mergeFrom:prototype];
}
- (LocalTimesBuilder*) builder {
  return [LocalTimes builder];
}
- (LocalTimesBuilder*) toBuilder {
  return [LocalTimes builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  [self.localTimeArray enumerateObjectsUsingBlock:^(LocalTime *element, NSUInteger idx, BOOL *stop) {
    [output appendFormat:@"%@%@ {\n", indent, @"localTime"];
    [element writeDescriptionTo:output
                     withIndent:[NSString stringWithFormat:@"%@  ", indent]];
    [output appendFormat:@"%@}\n", indent];
  }];
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[LocalTimes class]]) {
    return NO;
  }
  LocalTimes *otherMessage = other;
  return
      [self.localTimeArray isEqualToArray:otherMessage.localTimeArray] &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  __block NSUInteger hashCode = 7;
  [self.localTimeArray enumerateObjectsUsingBlock:^(LocalTime *element, NSUInteger idx, BOOL *stop) {
    hashCode = hashCode * 31 + [element hash];
  }];
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

@interface LocalTimesBuilder()
@property (strong) LocalTimes* resultLocalTimes;
@end

@implementation LocalTimesBuilder
@synthesize resultLocalTimes;
- (instancetype) init {
  if ((self = [super init])) {
    self.resultLocalTimes = [[LocalTimes alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return resultLocalTimes;
}
- (LocalTimesBuilder*) clear {
  self.resultLocalTimes = [[LocalTimes alloc] init];
  return self;
}
- (LocalTimesBuilder*) clone {
  return [LocalTimes builderWithPrototype:resultLocalTimes];
}
- (LocalTimes*) defaultInstance {
  return [LocalTimes defaultInstance];
}
- (LocalTimes*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (LocalTimes*) buildPartial {
  LocalTimes* returnMe = resultLocalTimes;
  self.resultLocalTimes = nil;
  return returnMe;
}
- (LocalTimesBuilder*) mergeFrom:(LocalTimes*) other {
  if (other == [LocalTimes defaultInstance]) {
    return self;
  }
  if (other.localTimeArray.count > 0) {
    if (resultLocalTimes.localTimeArray == nil) {
      resultLocalTimes.localTimeArray = [[NSMutableArray alloc] initWithArray:other.localTimeArray];
    } else {
      [resultLocalTimes.localTimeArray addObjectsFromArray:other.localTimeArray];
    }
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (LocalTimesBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (LocalTimesBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSetBuilder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    SInt32 tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        LocalTimeBuilder* subBuilder = [LocalTime builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addLocalTime:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (NSMutableArray *)localTime {
  return resultLocalTimes.localTimeArray;
}
- (LocalTime*)localTimeAtIndex:(NSUInteger)index {
  return [resultLocalTimes localTimeAtIndex:index];
}
- (LocalTimesBuilder *)addLocalTime:(LocalTime*)value {
  if (resultLocalTimes.localTimeArray == nil) {
    resultLocalTimes.localTimeArray = [[NSMutableArray alloc]init];
  }
  [resultLocalTimes.localTimeArray addObject:value];
  return self;
}
- (LocalTimesBuilder *)setLocalTimeArray:(NSArray *)array {
  resultLocalTimes.localTimeArray = [[NSMutableArray alloc]initWithArray:array];
  return self;
}
- (LocalTimesBuilder *)clearLocalTime {
  resultLocalTimes.localTimeArray = nil;
  return self;
}
@end


// @@protoc_insertion_point(global_scope)
